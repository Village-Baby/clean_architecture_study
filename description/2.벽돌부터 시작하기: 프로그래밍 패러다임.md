# 2. 벽돌부터 시작하기: 프로그래밍 패러다임

```
소프트웨어 아키텍처는 코드로부터 시작한다.
패러다임이란 프로그래밍을 하는 방법으로, 언어에는 독립적이다.
패러다임은 어떤 프로그래밍 구조를 사용할지, 언제 이 구조를 사용해야 하는지를 결정한다.
```

1.[패러다임 개요](#1-패러다임-개요)
  - [구조적 프로그래밍](#구조적-프로그래밍)
  - [객체 지향 프로그래밍](#객체-지향-프로그래밍)
  - [함수형 프로그래밍](#함수형-프로그래밍)
  - [생각할 거리](#생각할-거리)
  - [결론](#결론1)

2.[구조적 프로그래밍](#2-구조적-프로그래밍)
  - [기능적 분해](#기능적-분해)
  - [결론](#결론2)

3.[객체 지향 프로그래밍](#3-객체-지향-프로그래밍)
  - [캡슐화](#캡슐화)
  - [상속](#상속)
  - [다형성](#다형성)
  - [결론](#결론3)

<br>
<br>

## 1. 패러다임 개요

<br>

### - 구조적 프로그래밍
goto문<br>
-> if/else/while 같은 구조로 대체

제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

<br>

### 객체 지향 프로그래밍
함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장한다.

제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

<br>

### 함수형 프로그래밍
할당문에 대해 규칙을 부과한다.

<br>

### 생각할 거리
각 패러다임은 프로그래머에게서 권한을 박탈한다.<br>
패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.<br>
3 가지 패러다임은 goto문, 함수 포인터, 할당문을 앗아갔다. 더이상 가져갈 것이 없을 것이다. 이외에 더이상 패러다임을 없을 것이다.

<br>

### 결론1

패러다임과 아키텍처의 관계

- 아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성을 이용
- 함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대한 규칙을 부과
- 모듈의 기반 알고리즘으로 구조적 프로그래밍을 사용
 

---

<br>
<br>

## 2. 구조적  프로그래밍

```
모든 프로그램은 순차(sequence), 분기(selection), 반복(iteration) 3가지 구조만으로 표현할 수 있다.
```

<br>

### 기능적 분해
모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있다 == 모듈을 기능적으로 분해할 수 있다

거대한 문제 기술서 <br>
-> 고수준의 기능들로 분해 가능 <br>
-> 저수준의 함수들로 분해 가능

<br>

### 결론2

소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 테스트되기 쉽도록 만들어야한다.
이를 위해 구조적 프로그래밍과 유사한 제한적인 규칙들을 활용해야 한다.

---

<br>
<br>

## 3. 객체 지향  프로그래밍

```
좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.
```

<br>

### 캡슐화

데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 만들수 있다. <br>
구분선 바깥에서 데이터는 은닉되고, 일부 함수만 노출된다. <br>
-> 클래스의 private 데이터와 public 함수로 표현

<br>

### 상속

어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 것과 같다.

<br>

### 다형성

프로그램이 장치 독립적이기를 원했다. <br>
-> 플러그인 아키텍처는 입출력 장치 독립성을 지원하기 위해 만들어졌다. <br>
-> 객체지향의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.

<br>

- 의존성 역전

  다형성을 활용하기 이전 메커니즘 <br>
  -> main 함수가 고수준 함수 호출
  -> 고수준 함수가 중간 수준 함수 호출
  -> 중간 수준 함수가 저수준 함수 호출
 
  <br>
 
  다형성을 활용하여 의존성 역전(dependency inversion)을 만든다.<br>
  소스 코드 의존성은 소스 코드 사이에 인터페이스를 추가해서 방향을 역전시킬 수 있다.

  <br>

  ![image](https://user-images.githubusercontent.com/40454769/191270878-94116760-a86b-4e5b-b270-39b6d259e4c6.png)

  
  의존성을 역전시켜서 UI와 데이터베이스가 비즈니스 룰에 의존하게 한다. <br>
  -> UI와 데이터베이스가 비지니스 룰의 플러그인이 된다. <br>
  -> UI와 데이터베이스에서 발생한 변경사항은 업무 규칙에 영향을 미치지 않는다. <br>
  -> 특정 컴포넌트의 소스코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포한다. <br>
  -> 배포 독립성 (independent deployability) <br>
  -> 서로 다른 팀에서 각 모듈을 독립적으로 개발가능 <br>
  -> 개발 독립성 (independent developability)

<br>

### 결론3

객체 지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획들할 수 있는 능력이다.

객체 지향을 사용하면 플러그인 아키텍처를 구성할 수 있고, 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
# 3. 설계 원칙

```
좋은 소프트웨어 시스템은 깔끔한 코드(clean code)로부터 시작한다.
SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 이 클래스를 서로 결합하는 방법을 설명해준다.

SOLID 원칙의 목적
- 변경에 유연하게 한다.
- 이해하기 쉽도록 한다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 되도록 한다.

SRP: 단일 책임 원칙(Single Responsibility Principle)
    - 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.

OCP: 개방 폐쇄 원칙(Open Closed Principle)
    - 기존 코드를 수정하기보다는 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야 시스템을 쉽게 변경할 수 있다.

LSP: 리스코프 치환 원칙(Liskov Substitution Principle)
    - 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 구성요소는 반드시 서로 치환 가능해야 한다.

ISP: 인터페이스 분리 원칙(Interface Segregation Principle)
    - 설계자는 사용하지 않은 것에 의존하지 않아야 한다.

DIP: 의존성 역전 원칙(Dependency Injection Principle)
    - 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다.

```

1.[단일 책임 원칙](#단일-책임-원칙)
- [우발적 중복](#우발적-중복)
- [해결책](#해결책)
- [결론](#결론1)

2.[개방 폐쇄 원칙](#개방-페쇄-원칙)
- [사고 실험](#사고-실험)
- [방향성 제어](#방향성-제어)
- [정보 은닉](#정보-은닉)
- [결론](#결론2)

<br>
<br>

## 단일 책임 원칙
단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.<br>
소프트웨어는 사용자와 이해관계자를 만족시키기 위해 변경된다.

사용자와 이해관계자 : actor
모듈 : 소스파일, 함수와 데이터 구조로 구성된 응집된(cohesive) 집합
cohesion : 단일 actor를 책임지는 코드를 함께 묶어주는 특성

<br>

### 우발적 중복
![](https://images.velog.io/images/kjha2142/post/ccd2a0fa-635d-49bf-89ed-2f5abb072a09/image.png)
이 Employee class는 SRP를 위반하고 있다.<br>
-> 3가지 method가 서로 다른 3명의 actor를 책임지고 있기 때문<br>
-> calculatePay()는 actor1이 사용<br>
-> reportHours()는 actor2가 사용<br>
-> save()는 actor3이 사용<br>
-> 현재 3명의 actor가 서로 결합되어 버렸다.(서로 의존하게 될 수 있다.)

### 해결책
Facade pattern을 이용해서 해결해볼 수 있다.
![](https://images.velog.io/images/kjha2142/post/42ef8c38-707f-4d6b-905b-cb4e1af61105/image.png)
EmployeeFacade는 3개의 class의 객체를 생성하고, 요청된 method를 가지는 객체로 위임하는 일을 책임진다.

<br>

### 결론1
단일 책임 원칙은 메서드 와 클래스 수준의 원칙이다.<br>
컴포넌트 수준에서는 공통 폐쇄원칙(Common Closure Principle), 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 축이 된다.
 

---


<br>
<br>

## 개방 폐쇄 원칙
소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.
요구사항을 살짝 확장하는 데 소프트웨어를 엄청나게 수정해야 한다면, 그 소프트웨어 시스템을 설계한 아키텍처는 엄청난 실패에 맞닥뜨린 것이다.

<br>

### 사고 실험
책임을 분리하여 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스코드 의존성을 확실히 해야한다.

행위가 확장될 때는 변경이 발생하지 않음을 보장해야한다.

![](https://images.velog.io/images/kjha2142/post/beabdc1d-3506-42be-ae23-42298f2065b0/image.png)

저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호해야 한다.<br>

위의 그림에서는 4개의 컴포넌트가 존재한다. <br>
Controller, Interactor, Database, Presenter+View

여기서 화살표는 의존성을 나타낸다.<br>
```
e.g.
A class가 B class에 의존한다.
A class에서는 B class를 호출하지만 반대는 호출하지 않는다.

e.g.
UI 가 Provider에 의존한다.
UI 에서는 Provider를 호출하지만 반대는 호출하지 않는다.
```
모든 화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.
```
A class에서 B class로 화살표 방향이 그려진다.
A class에서 코드 변경이 일어나도 B class는 영향을 받지 않는다.

View에서 발생한 변경은 Presenter에 영향이 없다.
Presenter에서 발생한 변경은 Controller에 영향이 없다.
Controller에서 발생한 변경은 Interactor에 영향이 없다.
Database에서 발생한 변경은 Interactor에 영향이 없다.

=> Interactor는 다른 컴포넌트들의 변경에 영향을 받지 않는다.
=> 업무규칙을 포함하고 있기 때문에 보호
=> 가장 높은 수준의 정책을 포함한다.
```
Interactor는 가장 높은 수준의 개념이고, View는 가장 낮은 수준의 개념이다.

<br>

### 방향성 제어
컴포넌트간의 의존성 방향을 유지하기 위해서 Interface를 활용한다.(의존성을 역전시킨다.)

<br>

### 정보 은닉
Interface는 방향성 제어뿐만 아니라 정보 은닉에도 사용한다.<br>
Controller에서 발생한 변경으로부터 Interactor를 보호하는 일의 우선순위가 가장 높지만, 반대로 Interactor에서 발생한 변경으로부터 Controller도 보호해야한다.

```
소프트웨어 원칙 : 자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다.

추이종속성 : 추이 종속성을 가지게 되면 위의 소프트웨어 원칙을 위반한다.
A class가 B class에 의존하고, B class가 C class에 의존하면 class A는 class C에 의존한다.
```
<br>

### 결론2
OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.

시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야한다.
 
---
# 3. 설계 원칙

```
좋은 소프트웨어 시스템은 깔끔한 코드(clean code)로부터 시작한다.
SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 이 클래스를 서로 결합하는 방법을 설명해준다.

SOLID 원칙의 목적
- 변경에 유연하게 한다.
- 이해하기 쉽도록 한다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 되도록 한다.

SRP: 단일 책임 원칙(Single Responsibility Principle)
    - 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.

OCP: 개방 폐쇄 원칙(Open Closed Principle)
    - 기존 코드를 수정하기보다는 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야 시스템을 쉽게 변경할 수 있다.

LSP: 리스코프 치환 원칙(Liskov Substitution Principle)
    - 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 구성요소는 반드시 서로 치환 가능해야 한다.

ISP: 인터페이스 분리 원칙(Interface Segregation Principle)
    - 설계자는 사용하지 않은 것에 의존하지 않아야 한다.

DIP: 의존성 역전 원칙(Dependency Injection Principle)
    - 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다.

```

1.[단일 책임 원칙](#단일-책임-원칙)
- [우발적 중복](#우발적-중복)
- [해결책](#해결책)
- [결론](#결론1)

2.[개방 폐쇄 원칙](#개방-페쇄-원칙)
- [사고 실험](#사고-실험)
- [방향성 제어](#방향성-제어)
- [정보 은닉](#정보-은닉)
- [결론](#결론2)

3.[리스코프 치환 원칙](#리스코프-치환-원칙)
- [상속을 사용하도록 가이드하기](#상속을-사용하도록-가이드하기)
- [정사각형 직사각형 문제](#정사각형-직사각형-문제)
- [LSP와 아키텍처](#LSP와-아키텍처)
- [LSP 위배 사례](#LSP-위배-사례)
- [결론](#결론3)

4.[인터페이스 분리 원칙](#인터페이스-분리-원칙)
- [ISP와 언어](#ISP와-언어)
- [ISP와 아키텍처](#ISP와-아키텍처)
- [결론](#결론4)

5.[의존성 역전 원칙](#의존성-역전-원칙)
- [안정된 추상화](#안정된-추상황)
- [팩토리](#팩토리)
- [구체 컴포넌트](#구체-컴포넌트)
- [결론](#결론5)

<br>
<br>

## 단일 책임 원칙
단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.<br>
소프트웨어는 사용자와 이해관계자를 만족시키기 위해 변경된다.

사용자와 이해관계자 : actor
모듈 : 소스파일, 함수와 데이터 구조로 구성된 응집된(cohesive) 집합
cohesion : 단일 actor를 책임지는 코드를 함께 묶어주는 특성

<br>

### 우발적 중복
![](https://images.velog.io/images/kjha2142/post/ccd2a0fa-635d-49bf-89ed-2f5abb072a09/image.png)
이 Employee class는 SRP를 위반하고 있다.<br>
-> 3가지 method가 서로 다른 3명의 actor를 책임지고 있기 때문<br>
-> calculatePay()는 actor1이 사용<br>
-> reportHours()는 actor2가 사용<br>
-> save()는 actor3이 사용<br>
-> 현재 3명의 actor가 서로 결합되어 버렸다.(서로 의존하게 될 수 있다.)

### 해결책
Facade pattern을 이용해서 해결해볼 수 있다.
![](https://images.velog.io/images/kjha2142/post/42ef8c38-707f-4d6b-905b-cb4e1af61105/image.png)
EmployeeFacade는 3개의 class의 객체를 생성하고, 요청된 method를 가지는 객체로 위임하는 일을 책임진다.

<br>

### 결론1
단일 책임 원칙은 메서드 와 클래스 수준의 원칙이다.<br>
컴포넌트 수준에서는 공통 폐쇄원칙(Common Closure Principle), 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 축이 된다.
 

---


<br>
<br>

## 개방 폐쇄 원칙
소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.
요구사항을 살짝 확장하는 데 소프트웨어를 엄청나게 수정해야 한다면, 그 소프트웨어 시스템을 설계한 아키텍처는 엄청난 실패에 맞닥뜨린 것이다.

<br>

### 사고 실험
책임을 분리하여 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스코드 의존성을 확실히 해야한다.

행위가 확장될 때는 변경이 발생하지 않음을 보장해야한다.

![](https://images.velog.io/images/kjha2142/post/beabdc1d-3506-42be-ae23-42298f2065b0/image.png)

저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호해야 한다.<br>

위의 그림에서는 4개의 컴포넌트가 존재한다. <br>
Controller, Interactor, Database, Presenter+View

여기서 화살표는 의존성을 나타낸다.<br>
```
e.g.
A class가 B class에 의존한다.
A class에서는 B class를 호출하지만 반대는 호출하지 않는다.

e.g.
UI 가 Provider에 의존한다.
UI 에서는 Provider를 호출하지만 반대는 호출하지 않는다.
```
모든 화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.
```
A class에서 B class로 화살표 방향이 그려진다.
A class에서 코드 변경이 일어나도 B class는 영향을 받지 않는다.

View에서 발생한 변경은 Presenter에 영향이 없다.
Presenter에서 발생한 변경은 Controller에 영향이 없다.
Controller에서 발생한 변경은 Interactor에 영향이 없다.
Database에서 발생한 변경은 Interactor에 영향이 없다.

=> Interactor는 다른 컴포넌트들의 변경에 영향을 받지 않는다.
=> 업무규칙을 포함하고 있기 때문에 보호
=> 가장 높은 수준의 정책을 포함한다.
```
Interactor는 가장 높은 수준의 개념이고, View는 가장 낮은 수준의 개념이다.

<br>

### 방향성 제어
컴포넌트간의 의존성 방향을 유지하기 위해서 Interface를 활용한다.(의존성을 역전시킨다.)

<br>

### 정보 은닉
Interface는 방향성 제어뿐만 아니라 정보 은닉에도 사용한다.<br>
Controller에서 발생한 변경으로부터 Interactor를 보호하는 일의 우선순위가 가장 높지만, 반대로 Interactor에서 발생한 변경으로부터 Controller도 보호해야한다.

```
소프트웨어 원칙 : 자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다.

추이종속성 : 추이 종속성을 가지게 되면 위의 소프트웨어 원칙을 위반한다.
A class가 B class에 의존하고, B class가 C class에 의존하면 class A는 class C에 의존한다.
```
<br>

### 결론2
OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.

시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야한다.
 
---


<br>
<br>

## 리스코프 치환 원칙

<br>

### 상속을 사용하도록 가이드하기
![](https://images.velog.io/images/kjha2142/post/62b63cad-6d73-4fe8-a6ea-290293749b4f/image.png)
_Billing_ 이라는 애플리케이션에서 _Licence_ 클래스의 _calcFee()_ 메서드를 호출한다.<br>
여기서 _PersonalLicense_ 와 _BusinessLicense_ 는 _Licence_ 클래스의 하위타입이다.

이 설계는 _Billing_ 애플리케이션의 행위가 _Licence_ 클래스의 하위타입 중 무엇을 사용하는지에 전혀 의존하지 않고, 하위타이들은 모두 _Licence_ 클래스 타입을 치환할 수 있기 때문에 LSP를 준수한다.

<br>

### 정사각형 직사각형 문제
![](https://images.velog.io/images/kjha2142/post/514d54fe-b166-45bd-923d-b659ab2e587b/image.png)

정사각형/직사각형 문제는 LSP를 위반하는 전형적인 문제이다.

```
Rectangle : 높이와 너비는 서로 독립적으로 변경될 수 있다.
Square : 높이와 너비는 반드시 함께 변경된다.

Square 는 Rectangle의 하위타입으로 적합하지 않다.
-> 치환 불가능

e.g.
Rectangle r = Square();
r.setW(5);
r.setH(5);
assert(r.area() == 10);
-> assert문은 실패하게 된다.

LSP 위반을 막기 위해서 User에 Rectangle이 실제로는 Square인지 검사하도록 if문을 추가할 수 있지만 그렇게 되면 User의 행위가 사용하는 타입에 의존하게 되므로 타입을 서로 치환할 수 없다.
```

<br>

### LSP와 아키텍처
LSP는 초창기에는 상속을 사용하도록 가이드하는 방법 정도로 간주되었지만, 시간이 지나면서 인터페이스와 구현체에도 적용되는 더 광범위한 원칙으로 변모했다.

<br>

### LSP 위배 사례
```
택시 파견 통합 서비스 예시
우리는 택시 파견 애플리케이션을 만들고 있다.
REST 인터페이스
- pickupAddress
- pickup
- destination
3가지 필드를 업체에 상관없이 동일한 방식으로 처리해야함

여기서 Acme라는 회사에서 인터페이스를 지키지않고 destination을 dest로 축약해서 사용했다고 한다.
Acme는 거대한 회사이고 커다란 고객이다. 어쩔수 없이 Acme를 위해서 예외처리 로직을 추가해야한다.
if(driver.getDispatchUri().startsWith('acme.com'))...
'acme' 라는 단어를 코드에 추가한다는 것 자체가 이해할 수 없는 온갖 종류의 에러가 발생할 가능성을 만들어버린다.
```


<br>

### 결론3
LSP는 아키텍처 수준까지 확장해야한다.
치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 별도 메커니즘을 추가해야 할 수 있기 때문이다.

---


<br>
<br>

## 인터페이스 분리 원칙
![](https://velog.velcdn.com/images/kjha2142/post/51196ec0-1cfe-45ed-8ac2-1ac85c21edf3/image.png)

위의 상황을 보면 User1, User2, User3는 OPS클래스의 오퍼레이션을 사용하는데 각각 op1, op2, op3만 사용한다. 이때 User1은 op1만 사용함에도 op2, op3에 의존하게 된다.

예를들어 op2의 소스 코드가 변경되면 User1도 다시 컴파일하여 배포해야 한다.<br>
이런 문제는 오퍼레이션을 인터페이스 단위로 분리하여 해결할 수 있다.

![](https://images.velog.io/images/kjha2142/post/bf3911e8-90bc-4612-ba94-31dea517c106/image.png)

위의 상황에서 User1은 U1Ops와 op1에만 의존하고 OPS에는 의존하지 않는다.

<br>

### ISP와 언어
위에서의 예제는 import문을 사용하도록 하는 정적 타입 언어에서 발생하는 사례이다. 파이썬 같은 동적 타입 언어에서는 import문 사용되신 런타임에 추론이 발생하므로 의존성이 없어 재컴파일, 재배포가 불필요하다.

<br>

### ISP와 아키텍처
일반적으로 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다. 불필요한 재컴파일과 재배포를 강제하기 때문이다. 더 고수준인 아키텍처 수준에서도 마찬가지 상황이 발생한다.

```
e.g.
S 시스템을 구축하는 상황이다.
이때 F라는 프레임워크를 사용할 것이다.
그리고 F라는 프레임워크 개발자는 특정한 D 데이터베이스를 반드시 사용하도록 만들었다고 하자
S는 F에 의존하고, F는 다시 D에 의존하게 된다.
이렇게 되면 문제가 있는 아키텍처가 만들어진다.
```
![](https://images.velog.io/images/kjha2142/post/60c63916-5592-4bc1-9176-07c462b3bfa1/image.png)
```
F, S에서는 불필요한 기능이 D에 포함된다고 가정하자.
그 기능으로 인해 D 내부가 변경되면, F를 재배포해야 할 수 있고 심지어 S도 마찬가지일 수 있다.
```


<br>

### 결론4
불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.
